# Number of players increased to 12 and rounds to 3
players = [f"Spelare {i+1}" for i in range(12)]
num_rounds = 3

def select_active_players(players, match_counts, last_round_resting):
    """
    Select players for the round, prioritizing those who have played fewer matches and didn't rest last round.
    """
    # Sort players based on the number of matches played, prioritizing those who have played fewer matches
    players.sort(key=lambda x: match_counts[x])

    # Ensure players who rested last round are prioritized to play this round
    if last_round_resting:
        for player in last_round_resting:
            players.remove(player)
            players.insert(0, player)

    # Select the first 8 players; the rest will rest this round
    active_players = players[:8]
    resting_players = players[8:]

    return active_players, resting_players

# Resetting tracking structures and setting up the schedule again
previous_partners = defaultdict(set)
schedule = []
last_round_resting = []
match_counts = {player: 0 for player in players}  # Tracking the number of matches each player has played

# Creating a schedule of matches
for _ in range(num_rounds):
    active_players, resting_players = select_active_players(players.copy(), match_counts, last_round_resting)
    try:  # Using try-except to catch the ValueError if the pairing logic encounters an issue
        pairs = create_pairs(active_players, previous_partners)
        matches = create_matches(pairs)

        # Update the match counts and resting players for the next round
        for player in active_players:
            match_counts[player] += 1
        last_round_resting = resting_players
        schedule.append((matches, resting_players))
    except ValueError as e:
        # If we catch a ValueError, it means we have a logic issue. We need to break the loop.
        break

(schedule, match_counts)  # Return both the schedule and the match counts for verification
